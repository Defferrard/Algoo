{"file":"C:\\Github\\Algoo\\core\\src\\pathfinding\\pathfinding.ts","mappings":"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","names":[],"sources":["C:\\Github\\Algoo\\core\\src\\pathfinding\\pathfinding.ts"],"sourcesContent":["import { Board, Coordinate, SimpleCoordinate } from '../board/';\nimport type { Node } from './';\nimport { orderBy } from 'lodash';\n\n/**\n * Find the shortest path from a starting point to an ending point on a board.\n * @param from\n * @param to\n * @param board\n * @param filter The list of tiles that can be used to find the path\n */\nexport function findPath(\n  from: SimpleCoordinate,\n  to: SimpleCoordinate,\n  board: Board,\n  filter: SimpleCoordinate[],\n): SimpleCoordinate[] {\n  if (!filter.some((n) => Coordinate.equals(n, from)) && !filter.some((n) => Coordinate.equals(n, to))) return [];\n\n  let openList: Node[] = []; // Open list is the next set of tiles to evaluate\n  const closedList: Node[] = []; // Closed list is the set of tiles already evaluated\n  const map: Node[][] = board.mapNodes;\n\n  // Get the minimal value of the mapModel greater than 0 for optimization by heuristic calculation\n  const minimalMovementCost = board.minimalMovementCost;\n\n  let current: Node = map[from.y][from.x]; // Start at the starting tile\n  current.g = 0;\n\n  while (!current.equals(to)) {\n    // Move the current tile from the open list to the closed list\n    closedList.push(current);\n    if (filter?.some((c) => Coordinate.equals(c, current))) {\n      checkNeighbors(current, getNeighbors(current, map), openList, closedList);\n      if (openList.length === 0) {\n        return [];\n      }\n      openList = orderedOpenList(openList, to, minimalMovementCost);\n    }\n    current = openList.shift()!;\n  }\n  return unwindPath(current);\n}\n\n/**\n * Order the open list by the heuristic value of the nodes\n * @param openList\n * @param to\n * @param minimalMovementCost\n */\nfunction orderedOpenList(openList: Node[], to: SimpleCoordinate, minimalMovementCost: number): Node[] {\n  return orderBy(openList, [(n: Node) => n.g + heuristic(n, to, minimalMovementCost)]);\n}\n\n/**\n * Unwind the path from the end to the start, by following the parent nodes\n * @param node The end node\n */\nfunction unwindPath(node: Node): Coordinate[] {\n  const path: Coordinate[] = []; // Path is the set of tiles to get from start to finish\n  while (node.parent) {\n    path.push(node);\n    node = node.parent;\n  }\n  return path;\n}\n\n/**\n * Check the neighbors of the current node, by updating their parent if the movement cost is lower\n * and adding them to the open list if they are not already in the closed list.\n * Update the G value of the neighbors.\n *\n * @param current\n * @param neighbors\n * @param openList\n * @param closedList\n */\nexport function checkNeighbors(current: Node, neighbors: Node[], openList: Node[], closedList: Node[]) {\n  for (const neighbor of neighbors) {\n    let movementCost = current.g + neighbor.cost;\n    if (movementCost < neighbor.g) {\n      neighbor.parent = current;\n      if (!openList.some((n) => n.equals(neighbor)) && !closedList.some((n) => n.equals(neighbor))) {\n        openList.push(neighbor);\n      }\n    }\n  }\n}\n\n/**\n * Get the neighbors of a node, by checking the 4 adjacent tiles.\n * @param node Node to get the neighbors of\n * @param nodes Global map of nodes\n */\nexport function getNeighbors(node: Node, nodes: Node[][]): Node[] {\n  // TODO : Optimize this\n  const neighbors: Node[] = [];\n\n  const width = nodes[0].length;\n  const height = nodes.length;\n\n  for (let i = 0; i < 4; i++) {\n    let direction = (i >> 1) * 2 - 1;\n    let x = node.x + (i % 2) * direction;\n    let y = node.y + ((i + 1) % 2) * direction;\n    if (x >= 0 && x < width && y >= 0 && y < height && nodes[y][x].cost >= 0) {\n      neighbors.push(nodes[y][x]);\n    }\n  }\n\n  // Filter out neighbors that are out of map\n  return neighbors;\n}\n\n/**\n * Calculate the heuristic value of a node, by calculating the Manhattan distance between the node and the target.\n * @param from\n * @param to\n * @param minimalMovementCost\n */\nfunction heuristic(from: SimpleCoordinate, to: SimpleCoordinate, minimalMovementCost: number = 0): number {\n  return (Math.abs(from.x - to.x) + Math.abs(from.y - to.y)) * minimalMovementCost;\n}\n"],"version":3}