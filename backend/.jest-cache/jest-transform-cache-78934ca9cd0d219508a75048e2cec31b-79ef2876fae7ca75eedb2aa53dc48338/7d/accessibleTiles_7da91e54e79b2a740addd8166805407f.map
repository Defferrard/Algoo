{"file":"C:\\Github\\Algoo\\core\\src\\pathfinding\\accessibleTiles.ts","mappings":";;AAIA,wCA6BC;AAjCD,qCAAgE;AAEhE,yBAAkD;AAElD,SAAgB,cAAc,CAC5B,IAAsB,EACtB,OAAe,EACf,KAAY,EACZ,MAA0B;IAE1B,MAAM,UAAU,GAAuB,EAAE,CAAC;IAC1C,MAAM,GAAG,GAAa,KAAK,CAAC,QAAQ,CAAC;IAErC,IAAI,QAAQ,GAAW,EAAE,CAAC,CAAC,iDAAiD;IAC5E,MAAM,UAAU,GAAW,EAAE,CAAC,CAAC,oDAAoD;IAEnF,IAAI,OAAO,GAAS,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,6BAA6B;IACtE,OAAO,CAAC,CAAC,GAAG,CAAC,CAAC;IACd,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,yCAAyC;IAEjE,OAAO,QAAQ,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;QAC3B,OAAO,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;QACtB,8DAA8D;QAC9D,QAAQ,CAAC,MAAM,CAAC,QAAQ,CAAC,OAAO,CAAC,OAAO,CAAC,EAAE,CAAC,CAAC,CAAC;QAC9C,UAAU,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;QACzB,IAAI,OAAO,CAAC,CAAC,IAAI,OAAO,IAAI,MAAM,EAAE,IAAI,CAAC,CAAC,eAAe,EAAE,EAAE,CAAC,kBAAU,CAAC,MAAM,CAAC,eAAe,EAAE,OAAO,CAAC,CAAC,EAAE,CAAC;YAC3G,UAAU,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;YACzB,IAAA,iBAAc,EAAC,OAAO,EAAE,IAAA,eAAY,EAAC,OAAO,EAAE,GAAG,CAAC,EAAE,QAAQ,EAAE,UAAU,CAAC,CAAC;QAC5E,CAAC;IACH,CAAC;IAED,qDAAqD;IACrD,OAAO,UAAU,CAAC;AACpB,CAAC","names":[],"sources":["C:\\Github\\Algoo\\core\\src\\pathfinding\\accessibleTiles.ts"],"sourcesContent":["import { Board, Coordinate, SimpleCoordinate } from '../board/';\nimport type { Node } from './';\nimport { checkNeighbors, getNeighbors } from './';\n\nexport function getAccessibles(\n  from: SimpleCoordinate,\n  maxCost: number,\n  board: Board,\n  filter: SimpleCoordinate[],\n): SimpleCoordinate[] {\n  const accessible: SimpleCoordinate[] = [];\n  const map: Node[][] = board.mapNodes;\n\n  let openList: Node[] = []; // Open list is the next set of tiles to evaluate\n  const closedList: Node[] = []; // Closed list is the set of tiles already evaluated\n\n  let current: Node = map[from.y][from.x]; // Start at the starting tile\n  current.g = 0;\n  openList.push(current); // Add the starting tile to the open list\n\n  while (openList.length > 0) {\n    current = openList[0];\n    // Move the current tile from the open list to the closed list\n    openList.splice(openList.indexOf(current), 1);\n    closedList.push(current);\n    if (current.g <= maxCost && filter?.some((otherCoordinate) => Coordinate.equals(otherCoordinate, current))) {\n      accessible.push(current);\n      checkNeighbors(current, getNeighbors(current, map), openList, closedList);\n    }\n  }\n\n  // Remove the starting tile from the accessible tiles\n  return accessible;\n}\n"],"version":3}