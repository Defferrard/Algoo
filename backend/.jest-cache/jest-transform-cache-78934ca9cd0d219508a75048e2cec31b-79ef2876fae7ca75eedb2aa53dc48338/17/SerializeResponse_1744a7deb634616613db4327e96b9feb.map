{"file":"C:\\Github\\Algoo\\backend\\src\\utils\\SerializeResponse.ts","mappings":";;AAMA,8CAgCC;AApCD,4EAA4E;AAC5E,6EAA8E;AAC9E,6EAA6D;AAE7D,SAAgB,iBAAiB,CAAgB,aAA2B;IAC1E,OAAO,UACL,MAAW,EACX,UAAkB,EAClB,UAAuE;QAEvE,MAAM,cAAc,GAAG,UAAU,CAAC,KAAK,CAAC;QACxC,IAAA,0BAAa,EAAC,cAAc,CAAC,CAAC;QAE9B,qCAAqC;QACrC,IAAA,4CAAc,EAAC,aAAa,CAAC,CAAC,MAAM,EAAE,UAAU,EAAE,UAAU,CAAC,CAAC;QAE9D,UAAU,CAAC,KAAK,GAAG,KAAK,WAAW,GAAG,IAAU;YAC9C,MAAM,UAAU,GAAG,MAAM,cAAc,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;YAC1D,IAAI,CAAC;gBACH,IAAI,MAAc,CAAC;gBACnB,IAAI,KAAK,CAAC,OAAO,CAAC,UAAU,CAAC,EAAE,CAAC;oBAC9B,MAAM,GAAG,CAAC,MAAM,OAAO,CAAC,GAAG,CACzB,UAAU,CAAC,GAAG,CAAC,CAAC,OAAO,EAAE,EAAE,CAAC,IAAA,kDAAoB,EAAC,aAAa,EAAE,OAAO,CAAC,CAAC,CAC1E,CAAsB,CAAC;gBAC1B,CAAC;qBAAM,CAAC;oBACN,MAAM,GAAG,CAAC,MAAM,IAAA,kDAAoB,EAAC,aAAa,EAAE,UAAU,CAAC,CAAsB,CAAC;gBACxF,CAAC;gBACD,OAAO,MAAM,CAAC;YAChB,CAAC;YAAC,OAAO,CAAC,EAAE,CAAC;gBACX,OAAO,CAAC,KAAK,CAAC,yCAAyC,MAAM,CAAC,WAAW,CAAC,IAAI,IAAI,UAAU,EAAE,CAAC,CAAC;gBAChG,MAAM,CAAC,CAAC;YACV,CAAC;QACH,CAAC,CAAC;QAEF,MAAM,CAAC,cAAc,CAAC,UAAU,CAAC,KAAK,EAAE,MAAM,EAAE,EAAE,KAAK,EAAE,UAAU,EAAE,CAAC,CAAC;IACzE,CAAC,CAAC;AACJ,CAAC","names":[],"sources":["C:\\Github\\Algoo\\backend\\src\\utils\\SerializeResponse.ts"],"sourcesContent":["import { DTO } from '@defferrard/algoo-core/src/dto';\nimport { Type } from '@defferrard/algoo-core/src/utils/Type';\nimport { assertNonNull } from '@defferrard/algoo-core/src/utils/assertions';\nimport { ClassType, transformAndValidate } from 'class-transformer-validator';\nimport { ResponseSchema } from 'routing-controllers-openapi';\n\nexport function SerializeResponse<D extends DTO>(ResPayloadDto: ClassType<D>) {\n  return function <ARGS extends unknown[], RETURN extends Type<D> | Type<D>[]>(\n    target: any,\n    methodName: string,\n    descriptor: TypedPropertyDescriptor<(...args: ARGS) => Promise<RETURN>>,\n  ): void {\n    const originalMethod = descriptor.value;\n    assertNonNull(originalMethod);\n\n    // Apply the ResponseSchema decorator\n    ResponseSchema(ResPayloadDto)(target, methodName, descriptor);\n\n    descriptor.value = async function (...args: ARGS) {\n      const resPayload = await originalMethod.apply(this, args);\n      try {\n        let result: RETURN;\n        if (Array.isArray(resPayload)) {\n          result = (await Promise.all(\n            resPayload.map((payload) => transformAndValidate(ResPayloadDto, payload)),\n          )) as unknown as RETURN;\n        } else {\n          result = (await transformAndValidate(ResPayloadDto, resPayload)) as unknown as RETURN;\n        }\n        return result;\n      } catch (e) {\n        console.error(`Failed to serialize the response from ${target.constructor.name}#${methodName}`);\n        throw e;\n      }\n    };\n\n    Object.defineProperty(descriptor.value, 'name', { value: methodName });\n  };\n}\n"],"version":3}